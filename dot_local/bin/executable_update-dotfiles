#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
update-dotfiles

Synchronize, review, and publish dotfile changes managed by chezmoi.

Default behavior is interactive and safe:
- Fetches remote and shows ahead/behind
- Shows `chezmoi diff` (machine vs repo)
- Optionally `chezmoi re-add`
- Shows git diff (uses delta if available)
- Optionally commit
- Optionally push or open a PR via gh

Usage:
  update-dotfiles [options]

Options:
  --check              Print status/diffs only; make no changes.
  -y, --yes            Assume "yes" for prompts (repo changes still require explicit flags).

  --no-fetch           Skip git fetch.
  --pull               Auto fast-forward pull when behind.
  --apply              Auto run `chezmoi apply` after pulling.

  --re-add             Auto run `chezmoi re-add` when chezmoi diff is non-empty.

  --commit             Auto commit repo changes.
  -m, --message MSG    Commit message (default: timestamped).

  --push               Auto push after commit.
  --pr                 Auto open PR via `gh` after commit.

  -h, --help           Show this help.

Examples:
  update-dotfiles
  update-dotfiles --check
  update-dotfiles -y --pull --apply --re-add --commit --push
  update-dotfiles --commit --pr
EOF
}

is_interactive() {
  [ -t 0 ]
}

ASSUME_YES=0
CHECK_ONLY=0
DO_FETCH=1
AUTO_PULL=0
AUTO_APPLY=0
AUTO_READD=0
AUTO_COMMIT=0
AUTO_PUSH=0
AUTO_PR=0
COMMIT_MSG=""

while [ $# -gt 0 ]; do
  case "$1" in
    --check)
      CHECK_ONLY=1
      ;;
    -y|--yes)
      ASSUME_YES=1
      ;;
    --no-fetch)
      DO_FETCH=0
      ;;
    --pull)
      AUTO_PULL=1
      ;;
    --apply)
      AUTO_APPLY=1
      ;;
    --re-add|--readd)
      AUTO_READD=1
      ;;
    --commit)
      AUTO_COMMIT=1
      ;;
    -m|--message)
      shift
      COMMIT_MSG="${1:-}"
      ;;
    --push)
      AUTO_PUSH=1
      ;;
    --pr)
      AUTO_PR=1
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "update-dotfiles: unknown argument: $1" >&2
      echo "Run: update-dotfiles --help" >&2
      exit 2
      ;;
  esac
  shift
done

# Mutual exclusions.
if [ "$AUTO_PUSH" -eq 1 ] && [ "$AUTO_PR" -eq 1 ]; then
  echo "update-dotfiles: choose at most one publish mode: --push or --pr" >&2
  exit 2
fi

# --check implies no changes.
if [ "$CHECK_ONLY" -eq 1 ]; then
  AUTO_PULL=0
  AUTO_APPLY=0
  AUTO_READD=0
  AUTO_COMMIT=0
  AUTO_PUSH=0
  AUTO_PR=0
fi

confirm() {
  local prompt="$1"
  local reply

  if [ "$ASSUME_YES" -eq 1 ]; then
    return 0
  fi

  if [ "$CHECK_ONLY" -eq 1 ]; then
    return 1
  fi

  # In non-interactive contexts (no stdin/TTY), default to "no".
  if ! is_interactive; then
    return 1
  fi

  read -r -p "$prompt [y/N] " reply
  [[ "$reply" == "y" || "$reply" == "Y" ]]
}

confirm_repo_change() {
  local prompt="$1"
  local reply

  if [ "$CHECK_ONLY" -eq 1 ]; then
    return 1
  fi

  # Never auto-approve repo-mutating actions.
  # Explicit flags (--re-add/--commit/--push/--pr) are the non-interactive path.
  if ! is_interactive; then
    return 1
  fi

  read -r -p "$prompt [y/N] " reply
  [[ "$reply" == "y" || "$reply" == "Y" ]]
}

prompt_choice() {
  # Usage: prompt_choice "Prompt" "default" "valid_chars" -> echoes choice or empty
  local prompt="$1"
  local default_choice="$2"
  local valid_chars="$3"
  local reply

  if [ "$ASSUME_YES" -eq 1 ]; then
    echo "$default_choice"
    return 0
  fi

  if [ "$CHECK_ONLY" -eq 1 ]; then
    echo ""
    return 0
  fi

  if ! is_interactive; then
    echo ""
    return 0
  fi

  read -r -p "$prompt" reply || true

  if [ -z "$reply" ]; then
    reply="$default_choice"
  fi

  if [[ "$reply" =~ ^[$valid_chars]$ ]]; then
    echo "$reply"
  else
    echo ""
  fi
}

require() {
  local cmd="$1"
  if ! command -v "$cmd" >/dev/null 2>&1; then
    echo "update-dotfiles: missing required command: $cmd" >&2
    exit 1
  fi
}

section() {
  echo ""
  echo "== $1 =="
}

# Ensure cargo-installed tools (like `delta`) are discoverable.
case ":$PATH:" in
  *":$HOME/.cargo/bin:"*) ;;
  *) export PATH="$HOME/.cargo/bin:$PATH" ;;
esac

require git
require chezmoi

DOTFILES_DIR="$(chezmoi source-path)"
if [ -z "$DOTFILES_DIR" ]; then
  DOTFILES_DIR="$HOME/gitty/dotfiles"
fi

if [ ! -d "$DOTFILES_DIR/.git" ]; then
  echo "update-dotfiles: not a git repo: $DOTFILES_DIR" >&2
  exit 1
fi

current_branch="$(git -C "$DOTFILES_DIR" rev-parse --abbrev-ref HEAD)"

echo "== Dotfiles repo =="
echo "$DOTFILES_DIR"
echo "Branch: $current_branch"

# Fetch remote state.
if [ "$DO_FETCH" -eq 1 ]; then
  section "Fetching remote"
  git -C "$DOTFILES_DIR" fetch --prune || true
fi

upstream=""
if upstream=$(git -C "$DOTFILES_DIR" rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null); then
  echo "Upstream: $upstream"
fi

section "Repo status"
git -C "$DOTFILES_DIR" status -sb

# Summarize ahead/behind.
ahead=0
behind=0
if [ -n "$upstream" ]; then
  read -r ahead behind < <(git -C "$DOTFILES_DIR" rev-list --left-right --count "HEAD...$upstream" 2>/dev/null || echo "0 0")
  echo "Ahead: $ahead  Behind: $behind"

  # Avoid making automatic decisions if history diverged.
  if [ "$behind" -gt 0 ] && [ "$ahead" -gt 0 ]; then
    section "Diverged"
    echo "update-dotfiles: local branch has diverged from upstream (ahead $ahead, behind $behind)." >&2
    echo "Resolve manually (rebase/merge), then re-run update-dotfiles." >&2
    exit 2
  fi

  # Allow fast-forward updates.
  if [ "$behind" -gt 0 ] && [ "$ahead" -eq 0 ]; then
    if [ "$AUTO_PULL" -eq 1 ] || confirm "Remote is ahead by $behind commit(s). Fast-forward pull?"; then
      if git -C "$DOTFILES_DIR" status --porcelain=v1 | command grep -q .; then
        echo "update-dotfiles: repo has uncommitted changes; skipping pull" >&2
      else
        git -C "$DOTFILES_DIR" pull --ff-only

        if [ "$AUTO_APPLY" -eq 1 ] || confirm "Apply repo state to this machine (chezmoi apply)?"; then
          chezmoi apply --force --no-tty
        fi
      fi
    fi
  fi
fi

# Show machine-vs-repo diff.
section "Local machine vs repo (chezmoi diff)"
tmp_diff="$(mktemp)"
chezmoi diff --no-pager >"$tmp_diff" 2>/dev/null || true
if [ -s "$tmp_diff" ]; then
  cat "$tmp_diff"
  if [ "$AUTO_READD" -eq 1 ] || confirm_repo_change "Import current machine state into the repo (chezmoi re-add)? This may overwrite repo changes."; then
    chezmoi re-add
  fi
else
  echo "No differences."
fi
rm -f "$tmp_diff"

# Repo changes.
section "Repo changes"
if git -C "$DOTFILES_DIR" status --porcelain=v1 | command grep -q .; then
  git -C "$DOTFILES_DIR" status -sb

  section "Changed files"
  git -C "$DOTFILES_DIR" status --porcelain=v1 | sed -E 's/^.. //' || true

  section "Diff"
  if command -v delta >/dev/null 2>&1; then
    git -C "$DOTFILES_DIR" -c core.pager=delta diff
  else
    git -C "$DOTFILES_DIR" diff
  fi

  if [ "$AUTO_COMMIT" -eq 1 ] || confirm_repo_change "Commit these repo changes?"; then
    default_msg="Update dotfiles $(date '+%Y-%m-%d %H:%M')"
    msg="$COMMIT_MSG"

    if [ -z "$msg" ] && [ "$ASSUME_YES" -eq 0 ] && [ "$CHECK_ONLY" -eq 0 ] && is_interactive; then
      read -r -p "Commit message (default: $default_msg): " msg
    fi

    if [ -z "$msg" ]; then
      msg="$default_msg"
    fi

    git -C "$DOTFILES_DIR" add -A
    git -C "$DOTFILES_DIR" commit -m "$msg"

    publish_choice=""
    if [ "$AUTO_PUSH" -eq 1 ]; then
      publish_choice="p"
    elif [ "$AUTO_PR" -eq 1 ]; then
      publish_choice="r"
    else
      if [ "$ASSUME_YES" -eq 1 ]; then
        publish_choice="s"
      else
        if command -v gh >/dev/null 2>&1; then
          publish_choice="$(prompt_choice "Publish: (p)ush to $current_branch, (r)PR via gh, (s)kip? [p/r/s] (default: p): " "p" "prs")"
        else
          publish_choice="$(prompt_choice "Publish: (p)ush to $current_branch or (s)kip? [p/s] (default: p): " "p" "ps")"
        fi
      fi
    fi

    if [ "$publish_choice" = "p" ]; then
      git -C "$DOTFILES_DIR" push
    elif [ "$publish_choice" = "r" ]; then
      if ! command -v gh >/dev/null 2>&1; then
        echo "update-dotfiles: gh not found; cannot open PR" >&2
        exit 1
      fi

      pr_branch="dotfiles-update-$(date '+%Y%m%d-%H%M%S')"

      section "Creating PR branch"
      git -C "$DOTFILES_DIR" checkout -b "$pr_branch"
      git -C "$DOTFILES_DIR" push -u origin "$pr_branch"

      section "Creating PR"
      (
        cd "$DOTFILES_DIR"
        gh pr create --base "$current_branch" --head "$pr_branch" --title "$msg" --body "Automated dotfiles update via update-dotfiles." || true
      )

      if confirm "Switch back to $current_branch?"; then
        git -C "$DOTFILES_DIR" checkout "$current_branch"
      fi
    fi
  fi
else
  echo "No repo changes."
fi

section "Done"
